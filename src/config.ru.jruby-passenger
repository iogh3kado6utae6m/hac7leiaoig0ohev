#!/usr/bin/env jruby
# config.ru for JRuby + Passenger production deployment
# Optimized for JRuby threading model

require 'bundler/setup'
require 'json'

# Configure JRuby-specific optimizations
if RUBY_ENGINE == 'jruby'
  # Enable ObjectSpace for better memory management
  require 'jruby'
  JRuby.objectspace = true
  
  # Set thread pool for better concurrency
  java_import 'java.util.concurrent.ForkJoinPool'
  
  # Enable JRuby optimizations
  $VERBOSE = nil # Reduce JRuby startup warnings in production
end

# Set environment
ENV['RACK_ENV'] ||= 'production'

# Configure logging for production
if ENV['RACK_ENV'] == 'production'
  # Use structured logging
  require 'logger'
  logger = Logger.new($stdout)
  logger.level = Logger.const_get((ENV['LOG_LEVEL'] || 'INFO').upcase)
  logger.formatter = proc do |severity, datetime, progname, msg|
    {
      timestamp: datetime.utc.iso8601,
      level: severity,
      pid: Process.pid,
      message: msg
    }.to_json + "\n"
  end
end

# Load application
require_relative 'prometheus_exporter'

# Configure Sinatra for production
PrometheusExporterApp.configure :production do
  set :logging, false # We handle logging ourselves
  set :dump_errors, false
  set :show_exceptions, false
  set :raise_errors, false
  
  # Enable static file serving with proper headers
  set :public_folder, File.dirname(__FILE__) + '/public'
  set :static_cache_control, [:public, :max_age => 31536000] # 1 year for static assets
end

# Middleware stack optimized for JRuby
use Rack::Deflater
use Rack::ConditionalGet
use Rack::ETag

# Health check middleware
use(Class.new do
  def initialize(app)
    @app = app
  end
  
  def call(env)
    if env['PATH_INFO'] == '/health'
      [200, {'Content-Type' => 'text/plain'}, ['healthy']]
    else
      @app.call(env)
    end
  end
end)

# Request logging middleware for production
if ENV['RACK_ENV'] == 'production'
  use(Class.new do
    def initialize(app)
      @app = app
      @logger = Logger.new($stdout)
    end
    
    def call(env)
      start_time = Time.now
      status, headers, body = @app.call(env)
      duration = Time.now - start_time
      
      @logger.info({
        method: env['REQUEST_METHOD'],
        path: env['PATH_INFO'],
        status: status,
        duration_ms: (duration * 1000).round(2),
        user_agent: env['HTTP_USER_AGENT'],
        remote_addr: env['REMOTE_ADDR']
      }.to_json)
      
      [status, headers, body]
    end
  end)
end

# Main application
run PrometheusExporterApp
